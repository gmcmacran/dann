% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sub_dann.R
\name{sub_dann}
\alias{sub_dann}
\title{Discriminant Adaptive Nearest Neighbor With Subspace Reduction}
\usage{
sub_dann(xTrain, yTrain, xTest, k = 5,
  neighborhood_size = min(floor(nrow(xTrain)/5), 50), epsilon = 1,
  probability = FALSE, weighted = FALSE, sphere = "mcd",
  numDim = ncol(xTrain)/2)
}
\arguments{
\item{xTrain}{Train features. Something easily converted to a numeric matrix.}

\item{yTrain}{Train classes. Something easily converted to a numeric matrix.}

\item{xTest}{Test features. Something easily converted to a numeric matrix.}

\item{k}{The number of data points used for final classificastion.}

\item{neighborhood_size}{The number of data points used to calcualate between and within class covariance.}

\item{epsilon}{Diaginal elemnts of a diagional matrix. 1 is the identity matirx.}

\item{probability}{Should probabilities instead of classes be returned?}

\item{weighted}{weighted argument to ncoord. See \code{\link[fpc]{ncoord }} for details.}

\item{sphere}{sphere argument to ncoord. See \code{\link[fpc]{ncoord }} for details.}

\item{numDim}{Dimention of subspace used by dann. See \code{\link[fpc]{ncoord }} for details.}
}
\value{
A numeric matrix containing class predictions or class probabilities.
}
\description{
Discriminant Adaptive Nearest Neighbor With Subspace Reduction
}
\details{
This is an implementation of Hastie and Tibshirani's sub-dann in section 4.1 of
\href{https://web.stanford.edu/~hastie/Papers/dann_IEEE.pdf}{Discriminant Adaptive Nearest
Neighbor Classificastion publication.}. It uses package fpc's ncoord to find the subspace. Then calls
dann.
}
\examples{
library(dann)
library(mlbench)
library(magrittr)
library(dplyr)
library(ggplot2)

######################
# Circle data with unrelated variables
######################
set.seed(1)
train <- mlbench.circle(500, 2) \%>\%
  tibble::as_tibble()
colnames(train) <- c("X1", "X2", "Y")

# Add 5 unrelated variables
train <- train \%>\%
  mutate(
    U1 = runif(500, -1, 1),
    U2 = runif(500, -1, 1),
    U3 = runif(500, -1, 1),
    U4 = runif(500, -1, 1),
    U5 = runif(500, -1, 1)
  )

xTrain <- train \%>\%
  select(X1, X2, U1, U2, U3, U4, U5) \%>\%
  as.matrix()

yTrain <- train \%>\%
  pull(Y) \%>\%
  as.numeric() \%>\%
  as.matrix()

test <- mlbench.circle(500, 2) \%>\%
  tibble::as_tibble()
colnames(test) <- c("X1", "X2", "Y")

# Add 5 unrelated variables
test <- test \%>\%
  mutate(
    U1 = runif(500, -1, 1),
    U2 = runif(500, -1, 1),
    U3 = runif(500, -1, 1),
    U4 = runif(500, -1, 1),
    U5 = runif(500, -1, 1)
  )

xTest <- test \%>\%
  select(X1, X2, U1, U2, U3, U4, U5) \%>\%
  as.matrix()

yTest <- test \%>\%
  pull(Y) \%>\%
  as.numeric() \%>\%
  as.matrix()

dannPreds <- dann(xTrain, yTrain, xTest, 7, 50, 1, FALSE)
mean(dannPreds == yTest) # Not a good model

subDannPreds <- sub_dann(xTrain, yTrain, xTest, 7, 50, 1, FALSE, weighted = FALSE, sphere = "mcd", numDim = 2)
mean(subDannPreds == yTest) # sub_dan does much better when unrelated variables are present.

rm(train, test)
rm(xTrain, yTrain)
rm(xTest, yTest)
rm(dannPreds, subDannPreds)
}
